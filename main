#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Data {
    int dia; 
    int mes; 
    int ano; 
} Data;

typedef struct Registro {
    char nome[100]; 
    int idade; 
    char rg[20]; 
    Data* entrada; 
} Registro;

typedef struct ELista {
    Registro* dados; 
    struct ELista* proximo; 
} ELista;

typedef struct Lista {
    ELista* inicio; 
    int qtd; 
} Lista;

typedef struct EFila {
    Registro* dados; 
    struct EFila* proximo; 
} EFila;

typedef struct Fila {
    EFila* head; 
    EFila* tail; 
    int qtd; 
} Fila;

typedef struct EABB {
    Registro* dados; 
    struct EABB* filhoEsq; 
    struct EABB* filhoDir; 
} EABB;

typedef struct ABB {
    EABB* raiz; 
    int qtd; 
} ABB;

typedef struct Operacao {
    int tipo;
    Registro* paciente;
    struct Operacao* proximo;
} Operacao;

typedef struct PilhaOperacao {
    Operacao* topo;
} PilhaOperacao;

void iniciopilha(PilhaOperacao* pilha) {
    pilha->topo = NULL;
}

void inicio_lista(Lista* lista) {
    lista->inicio = NULL;
    lista->qtd = 0;
}

void inicio_fila(Fila* fila) {
    fila->head = NULL;
    fila->tail = NULL;
    fila->qtd = 0;
}

void inicioABB(ABB* arvore) {
    arvore->raiz = NULL;
    arvore->qtd = 0;
}

void empilharOperacao(PilhaOperacao* pilha, int tipo, Registro* paciente) {
    Operacao* nova_operacao = (Operacao*)malloc(sizeof(Operacao));
    if (nova_operacao == NULL) {
        printf("Erro");
        return;
    }
    nova_operacao->tipo = tipo;
    nova_operacao->paciente = paciente;
    nova_operacao->proximo = pilha->topo;
    pilha->topo = nova_operacao;
}

Operacao* desempilhar_operacao(PilhaOperacao* pilha) {
    if (pilha->topo == NULL) {
        printf("Nenhuma operacao para desfazer.");
        return NULL;
    }
    Operacao* operacao = pilha->topo;
    pilha->topo = pilha->topo->proximo;
    return operacao;
}

void limpar_buffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

int rg_existente(Lista* lista, const char* rg) {
    ELista* atual = lista->inicio;
    while (atual != NULL) {
        if (strcmp(atual->dados->rg, rg) == 0) {
            return 1;
        }
        atual = atual->proximo;
    }
    return 0;
}

EABB* inserir(EABB* raiz, Registro* dados) {
    if (raiz == NULL) {
        EABB* novoNo = (EABB*)malloc(sizeof(EABB));
        if (novoNo == NULL) {
            printf("Erro\n");
            return NULL;
        }
        novoNo->dados = dados;
        novoNo->filhoEsq = NULL;
        novoNo->filhoDir = NULL;
        return novoNo;
    }
    if (dados->entrada->ano < raiz->dados->entrada->ano) {
        raiz->filhoEsq = inserir(raiz->filhoEsq, dados);
    } else if (dados->entrada->ano > raiz->dados->entrada->ano) {
        raiz->filhoDir = inserir(raiz->filhoDir, dados);
    }
    return raiz;
}

void inserir_pacienteABB(ABB* arvore, Registro* dados) {
    arvore->raiz = inserir(arvore->raiz, dados);
    arvore->qtd++;
}
void cadastrar_novo_paciente(Lista* lista, ABB* arvore) {
    Registro* p = (Registro*)malloc(sizeof(Registro));
    if (p == NULL) {
        printf("Erro.\n");
        return;
    }

    printf("\nDigite o nome do paciente: ");
    fgets(p->nome, sizeof(p->nome), stdin);
    p->nome[strcspn(p->nome, "\n")] = '\0';

    printf("Digite a idade do paciente: ");
    scanf("%d", &p->idade);
    limpar_buffer();

    char rg[20];
    while (1) {
        printf("Digite o RG: ");
        fgets(rg, sizeof(rg), stdin);
        rg[strcspn(rg, "\n")] = '\0';

        if (rg_existente(lista, rg)) {
            printf("RG ja existe\n");
        } else {
            strncpy(p->rg, rg, sizeof(p->rg) - 1);
            p->rg[sizeof(p->rg) - 1] = '\0';
            break;
        }
    }

    p->entrada = (Data*)malloc(sizeof(Data));
    if (p->entrada == NULL) {
        printf("Erro\n");
        free(p);
        return;
    }

    printf("Digite a data de entrada (dia, mes, ano): ");
    if (scanf("%d %d %d", &p->entrada->dia, &p->entrada->mes, &p->entrada->ano) != 3) {
        printf("Entrada de data errada\n");
        free(p->entrada);
        free(p);
        limpar_buffer();
        return;
    }
    limpar_buffer();

    ELista* novoElemento = (ELista*)malloc(sizeof(ELista));
    if (novoElemento == NULL) {
        printf("Erro\n");
        free(p->entrada);
        free(p);
        return;
    }

    novoElemento->dados = p;
    novoElemento->proximo = lista->inicio;
    lista->inicio = novoElemento;
    lista->qtd++;

    inserir_pacienteABB(arvore, p);
    printf("Paciente %s cadastrado\n", p->nome);
}
void exibir_ano(EABB* raiz) {
    if (raiz != NULL) {
        exibir_ano(raiz->filhoEsq);
        printf("Nome: %s, Ano de Entrada: %d\n", raiz->dados->nome, raiz->dados->entrada->ano);
        exibir_ano(raiz->filhoDir);
    }
}

void exibir_mes(EABB* raiz) {
    if (raiz != NULL) {
        exibir_mes(raiz->filhoEsq);
        printf("Nome: %s, Mes de Entrada: %d/%d\n", raiz->dados->nome, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
        exibir_mes(raiz->filhoDir);
    }
}

void exibir_dia(EABB* raiz) {
    if (raiz != NULL) {
        exibir_dia(raiz->filhoEsq);
        printf("Nome: %s, Data de Entrada: %02d/%02d/%04d\n", raiz->dados->nome, raiz->dados->entrada->dia, raiz->dados->entrada->mes, raiz->dados->entrada->ano);
        exibir_dia(raiz->filhoDir);
    }
}

void exibir_idade(EABB* raiz) {
    if (raiz != NULL) {
        exibir_idade(raiz->filhoEsq);
        printf("Nome: %s, Idade: %d\n", raiz->dados->nome, raiz->dados->idade);
        exibir_idade(raiz->filhoDir);
    }
}

void consulta_paciente(Lista* lista) {
    if (lista->inicio == NULL) {
        printf("Nenhum paciente cadastrado\n");
        return;
    }

    char rg[20];
    printf("\nDigite o RG do paciente: ");
    fgets(rg, sizeof(rg), stdin);
    rg[strcspn(rg, "\n")] = '\0';

    ELista* atual = lista->inicio;
    while (atual != NULL) {
        if (strcmp(atual->dados->rg, rg) == 0) {
            Registro* reg = atual->dados;
            printf("\nPaciente encontrado:\n");
            printf("Nome: %s, Idade: %d, RG: %s, Data de Entrada: %02d/%02d/%04d\n",
                   reg->nome, reg->idade, reg->rg, reg->entrada->dia, reg->entrada->mes, reg->entrada->ano);
            return;
        }
        atual = atual->proximo;
    }
    printf("Paciente com RG %s nao encontrado.\n", rg);
}

void exibir_pacientes_lista(Lista* lista) {
    if (lista->inicio == NULL) {
        printf("Nenhum paciente cadastrado.\n");
        return;
    }

    ELista* atual = lista->inicio;
    printf("\nPacientes cadastrados (Total: %d):\n", lista->qtd);
    while (atual != NULL) {
        Registro* reg = atual->dados;
        printf("Nome: %s, Idade: %d, RG: %s, Data de Entrada: %02d/%02d/%04d\n",
               reg->nome, reg->idade, reg->rg, reg->entrada->dia, reg->entrada->mes, reg->entrada->ano);
        atual = atual->proximo;
    }
}

void atualizar_paciente(Lista* lista) {
    if (lista->inicio == NULL) {
        printf("Nenhum paciente cadastrado.\n");
        return;
    }

    char rg[20];
    printf("\nDigite o RG do paciente que deseja atualizar: ");
    fgets(rg, sizeof(rg), stdin);
    rg[strcspn(rg, "\n")] = '\0';

    ELista* atual = lista->inicio;
    while (atual != NULL) {
        if (strcmp(atual->dados->rg, rg) == 0) {
            Registro* reg = atual->dados;
            printf("\nAtualizando dados do paciente %s:\n", reg->nome);
            printf("Digite o novo nome do paciente: ");
            fgets(reg->nome, sizeof(reg->nome), stdin);
            reg->nome[strcspn(reg->nome, "\n")] = '\0';

            printf("Digite a nova idade do paciente: ");
            scanf("%d", &reg->idade);
            limpar_buffer();

            printf("Digite a nova data de entrada (dia, mes, ano): ");
            scanf("%d %d %d", &reg->entrada->dia, &reg->entrada->mes, &reg->entrada->ano);
            limpar_buffer();

            printf("Dados do paciente atualizados com sucesso!\n");
            return;
        }
        atual = atual->proximo;
    }
    printf("Paciente com RG %s nao encontrado.\n", rg);
}

void remover_paciente(Lista* lista) {
    if (lista->inicio == NULL) {
        printf("Nenhum paciente cadastrado.\n");
        return;
    }
    char rg[20];
    printf("\nDigite o RG do paciente que quer remover: ");
    fgets(rg, sizeof(rg), stdin);
    rg[strcspn(rg, "\n")] = '\0';

    ELista* atual = lista->inicio;
    ELista* anterior = NULL;
    while (atual != NULL) {
        if (strcmp(atual->dados->rg, rg) == 0) {
            if (anterior == NULL) {
                lista->inicio = atual->proximo;
            } else {
                anterior->proximo = atual->proximo;
            }
            printf("Paciente %s removido\n", atual->dados->nome);
            free(atual->dados->entrada);
            free(atual->dados);
            free(atual);
            lista->qtd--;
            return;
        }
        anterior = atual;
        atual = atual->proximo;
    }
    printf("Paciente com RG %s nao encontrado.\n", rg);
}
void enfileira_paciente(Fila* fila, Registro* paciente) {
    EFila* novoElemento = (EFila*)malloc(sizeof(EFila));
    if (novoElemento == NULL) {
        printf("Erro\n");
        return;
    }
    novoElemento->dados = paciente;
    novoElemento->proximo = NULL;

    if (fila->tail == NULL) {
        fila->head = novoElemento;
    } else {
        fila->tail->proximo = novoElemento;
    }
    fila->tail = novoElemento;
    fila->qtd++;

    printf("Paciente %s enfileirado para atendimento\n", paciente->nome);
}

void desenfileirar_paciente(Fila* fila) {
    if (fila->head == NULL) {
        printf("Nenhum paciente na fila de atendimento\n");
        return;
    }

    EFila* removido = fila->head;
    fila->head = fila->head->proximo;
    if (fila->head == NULL) {
        fila->tail = NULL;
    }
    printf("Paciente %s atendido e removido da fila\n", removido->dados->nome);
    free(removido);
    fila->qtd--;
}

void exibirFila(Fila* fila) {
    if (fila->head == NULL) {
        printf("Nenhum paciente na fila de atendimento\n");
        return;
    }

    EFila* atual = fila->head;
    printf("\nPacientes na fila de atendimento (Total: %d):\n", fila->qtd);
    while (atual != NULL) {
        Registro* reg = atual->dados;
        printf("Nome: %s, Idade: %d, RG: %s, Data de Entrada: %02d/%02d/%04d\n",
               reg->nome, reg->idade, reg->rg, reg->entrada->dia, reg->entrada->mes, reg->entrada->ano);
        atual = atual->proximo;
    }
}

void salvar_dados(Lista* lista) {
    FILE* arquivo = fopen("dados_pacientes.txt", "w");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para salvar os dados.\n");
        return;
    }

    ELista* atual = lista->inicio;
    while (atual != NULL) {
        Registro* p = atual->dados;
        fprintf(arquivo, "%s,%d,%s,%d %d %d\n", p->nome, p->idade, p->rg, p->entrada->dia, p->entrada->mes, p->entrada->ano);
        atual = atual->proximo;
    }

    fclose(arquivo);
    printf("Dados salvos com sucesso.\n");
}

void carregar_dados(Lista* lista, ABB* arvore) {
    FILE* arquivo = fopen("dados_pacientes.txt", "r");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para carregar os dados.\n");
        return;
    }

    char linha[256];
    while (fgets(linha, sizeof(linha), arquivo)) {
        Registro* p = (Registro*)malloc(sizeof(Registro));
        if (p == NULL) {
            printf("Erro ao alocar memoria para registro.\n");
            fclose(arquivo);
            return;
        }

        p->entrada = (Data*)malloc(sizeof(Data));
        if (p->entrada == NULL) {
            printf("Erro ao alocar memoria para data.\n");
            free(p);
            fclose(arquivo);
            return;
        }

        sscanf(linha, "%[^,],%d,%[^,],%d %d %d", p->nome, &p->idade, p->rg, &p->entrada->dia, &p->entrada->mes, &p->entrada->ano);

        ELista* novoElemento = (ELista*)malloc(sizeof(ELista));
        if (novoElemento == NULL) {
            printf("Erro ao alocar memoria para elemento da lista.\n");
            free(p->entrada);
            free(p);
            fclose(arquivo);
            return;
        }

        novoElemento->dados = p;
        novoElemento->proximo = lista->inicio;
        lista->inicio = novoElemento;
        lista->qtd++;

        inserir_pacienteABB(arvore, p);
    }

    fclose(arquivo);
    printf("Dados carregados com sucesso.\n");
}

void desfazer_operacao(PilhaOperacao* pilha, Lista* lista, Fila* fila) {
    Operacao* operacao = desempilhar_operacao(pilha);
    if (operacao == NULL) return;

    switch (operacao->tipo) {
        case 1: {
            ELista* atual = lista->inicio;
            ELista* anterior = NULL;
            while (atual != NULL) {
                if (atual->dados == operacao->paciente) {
                    if (anterior == NULL) {
                        lista->inicio = atual->proximo;
                    } else {
                        anterior->proximo = atual->proximo;
                    }
                    printf("Cadastro retirado %s\n", operacao->paciente->nome);
                    free(atual->dados->entrada);
                    free(atual->dados);
                    free(atual);
                    lista->qtd--;
                    break;
                }
                anterior = atual;
                atual = atual->proximo;
            }
            break;
        }
        case 2: {
            if (fila->tail == NULL) {
                printf("Erro ao desfazer enfileiramento\n");
                break;
            }
            EFila* atual = fila->head;
            EFila* anterior = NULL;
            while (atual != NULL) {
                if (atual->dados == operacao->paciente) {
                    if (anterior == NULL) {
                        fila->head = atual->proximo;
                    } else {
                        anterior->proximo = atual->proximo;
                    }
                    if (atual == fila->tail) {
                        fila->tail = anterior;
                    }
                    printf("Paciente tirado da fila %s\n", operacao->paciente->nome);
                    free(atual);
                    fila->qtd--;
                    break;
                }
                anterior = atual;
                atual = atual->proximo;
            }
            break;
        }
        default:
            printf("operacao nao encontrada.\n");
    }
    free(operacao);
}
